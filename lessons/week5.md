##[Ruby Topics](https://github.com/hsgroves/cs290info/blob/master/ruby_topics.md)

##Steps you should be taking for your own project
At this point, you should be thinking of how you're going to split your app idea up into Rails models. Example: a to-do list app will almost certainly require a List model and a ListItem model, related with a `has_many`/`belongs_to` relationship. You might also want to put a user system in place; then a User and Lists would also have a `has_many`/`belongs_to` relationship.

Please send me a Slack message by **next Tuesday, March 8** that details the models in your app, the fields each models have, and any relationships between your models. You should also actually be creating the models in your app. Feel free to ask me/another student/the internet for help with any specifics!

##Devise and ActiveAdmin
[Devise](https://github.com/plataformatec/devise) is a free, open source Ruby gem for Rails authentication (user login).

[ActiveAdmin](https://github.com/activeadmin/activeadmin) is a free, open-source Ruby gem that contains a Rails engine (a mini Rails app that runs within another Rails app). It gives you an *extremely* robust administrative interface with minimal setup.

##Devise Install
You can't have a user admin interface without first having users! So let's make that happen.

###Setting a root route
Remember, routes map an HTTP request to a controller function. When you set the "root" route, you set the configuration for the landing page of your app (with no extra URI path).

In routes.rb:
`root 'posts#index'`

This means that when we visit https://ruby-setup-hsgroves.c9users.io, we will be taken to the index action of our Post model. Note that https://ruby-setup-hsgroves.c9users.io/posts will *also* take us to the index action of our Post model.

###Include & install the Devise gem
Add a line in your Gemfile:
`gem 'devise'`

Then, run `bundle install` in your terminal.

###Generate configuration, User model, and views
In your terminal, run the following:

```
bundle exec rails generate devise:install  # generates configuration files (we'll edit these later)
```

That prompts you to add some configuration. We already did step 2, but we haven't added `default_url_options` in our config/environments/development.rb file. Open that and paste the following after line 17, like the Devise instructions suggest:

`config.action_mailer.default_url_options = { host: 'localhost', port: 3000 }`

Let's also follow step 3, and add flash notices to our HTML templates. We'll talk more about flash notices and ERB later this semester. While we're at it, we'll add sign in/sign out links to our app. In app/views/layouts/application.html.erb, after the `<body>` tag on line 9:

```
<p class="notice"><%= notice %></p>
<p class="alert"><%= alert %></p>
<% if user_signed_in? %>
  <li>
  <%= link_to('Logout', destroy_user_session_path, method: :delete) %>        
  </li>
<% else %>
  <li>
  <%= link_to('Login', new_user_session_path)  %>  
  </li>
<% end %>
```

We aren't using Rails 3.2 or deploying to Heroku, so no need to follow step 4; we'll get to step 5 in a moment.

Now, let's create a User model to use with Devise.

```
bundle exec rails generate devise User     # generates a user model
```

Just like after we used `rails generate scaffold` to create our Post model, we now need to apply the schema migration generated by the second line above.

```
bundle exec rake db:migrate
```

Now that we've got a User model, we can generate HTML views for it (so that a real live user can create an account).

```
bundle exec rails generate devise:views users
```

##ActiveAdmin Install
And now that we have users, let's give certain users admin rights, so that they can moderate blog posts and future features (like comments and tags).

###Include & install the ActiveAdmin gem
Add a line in your Gemfile:
`gem 'activeadmin', github: 'activeadmin'`

Notice that we're specifying that we want to install the specific version of ActiveAdmin that . We're doing this because previous major releases of ActiveAdmin are not compatible with Rails 4.

Save the Gemfile and run `bundle install` in your terminal.

###Run generator
We already have a User model. It makes sense that blog administrators might start out as regular users, and should have all capabilities that regular users have, too. So we're going to run the ActiveAdmin generator, and tell it to use our existing User model to configure for ActiveAdmin.

```
bundle exec rails g active_admin:install User
```

This also will create a migration file called `add_devise_to_users.rb` (preceded by a timestamp). We need to delete this file; since we created the User model with Devise, Devise has already been added to it.

In order to use the same user model for admins and regular users, we need to make some other changes, too. Open `config/routes.rb` and remove the duplicate lines 4 and 5.

We'll also need to change line 2 to allow Devise to log in users who aren't administrators. Right now, it says to configure Devise logins with ActiveAdmin's default configuration. Change it to just `devise_for :users` to leave out ActiveAdmin.

To be able to tell the difference between admin users and non-admin users, we need to add a flag to our User model. First, generate the migration:
```
bundle exec rails g migration AddAdminFlagToUsers is_admin:boolean
```

When we installed ActiveAdmin, it created a *seed* (a predefined record meant to be stored in the database, usually applied at the beginning of a project) for an Admin user. We need to update that to include our `is_admin` flag, and while we're at it, we'll add a non-admin user, too. Open `db/seeds.rb` and duplicate line 8. On one of the lines, add `is_admin: true` to the parameters being passed to `User.create!`. On the other, change the username and password to something else (but remember, this will be committed publicly to GitHub, so it's a good idea to use dummy data and not your email address or a password you use).

We also need to make sure that only Admin users can access the ActiveAdmin dashboard. First, we'll create a method in `app/application_controller.rb` (the controller for the entire application) to check if a user is an admin. After line 4:

```
  def admin_required
    current_user.is_admin? || redirect_to('/')
  end
```

We're going to have ActiveAdmin apply this method before each of its controller actions, so that users who are not admins will be redirected to the root of the site if they try to access an admin page. In `config/initializers/active_admin.rb`, change line 4 to:

```

```

Now, we'll run the migrations and add seeds for a default Admin user (the ActiveAdmin generator added that to `db/seeds.rb`), so that we can log in:

```
bundle exec rake db:migrate
bundle exec rake db:seed
```

Whenever you do something like install a new gem, change configuration, or apply a migration to your database, you'll need to restart your server.

Once we restart our server, we can visit `https://ruby-setup-hsgroves.c9users.io/admin` and log in with the default credentials:

- User: admin@example.com
- Password: password

###Viewing Posts in the ActiveAdmin Dashboard
We've got this sweet dashboard now, but it doesn't actually show our posts - that's because we haven't told ActiveAdmin which models it should show. To do that, we'll run the ActiveAdmin resource generator:

```
bundle exec rails generate active_admin:resource Post
```

This created `app/admin/post.rb`. Take a look - it's pretty empty, except some comments about "permitted params". Earlier versions of Rails allowed for a security hole in accepting parameters, if not set up properly; Rails 4 introduced "strong parameters," or a parameter whitelist, to allow only expected parameters to be passed to any given controller function. So we'll follow the suggestion, and add some permitted params to our Admin post model:

```
permit_params :title, :body, :username
```

##Connecting Users and Posts
So far, we've added users and an admin interface to our system... but we haven't done anything to connect a blog post with the user who made it. Let's do that now!

First, in order to connect the two models, we'll need to store a `user_id` for each Post. Let's create and apply a migration for that change:

```
bundle exec rails g migration AddUserRefToPosts user:references
bundle exec rake db:migrate
```

In `app/models/post.rb`, add the following:
```
belongs_to :user
```

In `app/models/user.rb`, add the following:
```
has_many :posts
```

Now, we'll need to ....

##Coming next week
Right now, it doesn't make a difference whether you're an admin or not - anyone can do anything to any Post. We're going to fix that, and try to make the user-facing site a little more structure.
